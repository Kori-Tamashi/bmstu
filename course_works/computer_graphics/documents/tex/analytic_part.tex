\chapter{Аналитическая часть}

В этом разделе рассматриваются объекты сцены, способы их представления и существующие алгоритмы создания изображений, а также осуществляется выбор наиболее подходящих из этих алгоритмов для дальнейшего применения.

\section{Формализация объектов сцены}

Сцена является набором объектов, включащим в себя:

\begin{enumerate}
	\item объекты сцены -- геометрические многогранные примитивы, расположенные в пространстве сцены, такие как, куб, прямая призма треугольная пирамида. Каждый примитив состоит из граней, сформированных из точек соединенных ребрами. Геометрические характеристики примитивов задаются параметрами такими, как длина ребра основания, высота, радиусы описанных окружностей нижнего и верхнего основания, количество боковых граней. Спектральные характеристики так же задаются параметрами такими, как коэффициенты отражения и блеска, цвет.
	\item источник света -- пространственный вектор, указывающий направление света. Свет всегда направлен вдоль положительной оси $Z$, его положение в пространстве сцены задается пользователем.
	\item камера -- пространственный вектор, указывающий направление просмотра.
\end{enumerate}

\section{Анализ способов представления модели}

\begin{enumerate}
	\item \textit{каркасная модель} -- простейший способ представления моделей, основанный на использовании точек и рёбер, содержащий минимум иформации и имеющий ряд ограничений. Основным недостатком является неоднозначность, так как невозможно четко определить ориентацию и видимость, что может привести к непредсказуемым результатам. Удаление скрытых линий требует ручного редактирования, что может разрушить целостность модели. 
	\begin{figure}[h] 
		\centering
		\includegraphics[width=0.6\textwidth]{images/carcass-models.png}
		\caption{Каркасные модели} 
		\label{fig:carcass-models} 
	\end{figure}
	Также каркасные модели не поддерживают технику тонового изображения, так как затенение применяется к граням, а не к ребрам, что ограничивает их использование в задачах, требующих визуальной глубины и реалистичности. Несмотря на эти ограничения, каркасные модели требуют меньше памяти и легки в отрисовке. Пример каркасных моделей приведён на рисунке \ref{fig:carcass-models}.
	
	\item \textit{поверхностная модель} -- способ представления моделей, основанный на использовании точек, линий и поверхностей, что делает его более гибким и многофункциональным по сравнению с каркасной моделью. Он позволяет изображать сложные криволинейные грани, создавать тоновые трехмерные изображения и выявлять особенности, такие как отверстия. Этот метод обеспечивает высокое качество изображений. Поверхностную модель можно задать двумя способами:
	\begin{itemize}[label=--]
		\item \textit{параметрическое представление} -- вид поверхностной модели, требующий вычисления функции, зависящей от параметра, но его использование затруднено в сценах без поверхностей вращения;
		\item \textit{полигональная сетка} -- вид поверхностной модели, представленный совокупностью вершин, рёбер и граней. Гранями обычно являются треугольники, четырёхугольники или другие простые выпуклые многоугольники, но могут также являться многоугольниками с отверстиями. Пример поверхностной модели, заданной полигональной сеткой, приведён на рисунке \ref{fig:polygonal-models}.
	\end{itemize}
	\begin{figure}[h] 
		\centering
		\includegraphics[width=0.5\textwidth]{images/polygonal-models.png}
		\caption{Поверхностая модель, заданная полигональной сеткой} 
		\label{fig:polygonal-models} 
	\end{figure}
	Однако у поверхностной модели есть недостаток: она не предоставляет информации о том, с какой стороны поверхности находится материал.
	
	\item \textit{твердотельная модель} -- способ представления моделей, включающий информацию о внутренней структуре и расположении материала, в отличие от поверхностной модели, что достигается указанием направления внутренней нормали.
	\begin{figure}[h] 
		\centering
		\includegraphics[width=0.5\textwidth]{images/solidum-statu-models.png}
		\caption{Твердотельная модель} 
		\label{fig:solidum-statu-models} 
	\end{figure}
	Твердотельные модели обладают неоспоримыми преимуществами, включая полное определение объемной формы с разграничением внешних и внутренних областей, что позволяет избежать нежелательных взаимовлияний компонентов. Они обеспечивают автоматическое удаление скрытых линий и построение трехмерных разрезов, что важно для анализа сложных композиций. Пример твердотельной модели приведён на рисунке \ref{fig:solidum-statu-models}.
\end{enumerate}
	
Для выполнения данной работы каркасная модель не подходит, так как она может исказить восприятие форм объекта. Твердотельная модель так же не является оптимальной, поскольку в этой работе не требуется информация о материале и его расположении. Таким образом, остается только поверхностная модель как наилучший выбор. 

Поверхностная модель будет задана полигональной сеткой, так как в этой работе не будет обработки поверхностей вращения и использование параметрического представления избыточно.

\section{Анализ способов представления поверхностной модели, заданной полигональной сеткой}

Объекты, созданные с помощью полигональных сеток, должны хранить разные типы элементов, такие как вершины, рёбра, грани, полигоны и поверхности. Во многих случаях хранятся лишь вершины, рёбра и либо грани, либо полигоны (рис. \ref{fig:polygonal-models-example}). Грани могут быть как трехсторонними, так и четырехсторонними.

\begin{figure}[h] 
	\centering
	\includegraphics[width=0.7\textwidth]{images/polygonal-models-example.png}
	\caption{Элементы моделирования сетки} 
	\label{fig:polygonal-models-example} 
\end{figure}

\begin{enumerate}
	\item \textit{вершинное представление} -- простейший способ представления, описывающий объект как набор вершин, соединённых с другими вершинами. Хотя это и простейший способ представления, он не так широко используется, поскольку не предоставляет явной информации о гранях и рёбрах. 
	\begin{figure}[h] 
		\centering
		\includegraphics[width=0.7\textwidth]{images/vertex-list.png}
		\caption{Вершинное представление} 
		\label{fig:vertex-list} 
	\end{figure}
	Это означает, что для генерации списка граней, необходимого для рендеринга, нужно обойти все данные, что усложняет выполнение операций с рёбрами и гранями. Пример полигональной сетки, заданной вершинным представлением приведён на рисунке \ref{fig:vertex-list}.
	
	\item \textit{список граней} -- способ представления, описывающий объект как множество вершин и граней, который является наиболее распространённым представлением для современного графического оборудования. Это представление упрощает моделирование, позволяя легко находить грани, окружающие конкретные вершины. Пример полигональной сетки, заданной списком граней приведён на рисунке \ref{fig:planes-list}. 
	\begin{figure}[h] 
		\centering
		\includegraphics[width=0.8\textwidth]{images/planes-list.png}
		\caption{Список граней} 
		\label{fig:planes-list} 
	\end{figure}
	
	\item \textit{<<крылатое>> представление} -- способ представления, описывающий объект как множество вершин, граней и рёбер, что обеспечивает высокую гибкость в динамическом изменении геометрии. «Крылатое» представление эффективно решает задачу обхода от ребра к ребру, предоставляя упорядоченное множество граней вокруг каждого ребра. Оно включает информацию о двух конечных вершинах, двух гранях и четырёх ближайших рёбрах. Пример полигональной сетки, заданной <<крылатым>> представлением приведён на рисунке \ref{fig:wings-list}. 
	\begin{figure}[h] 
		\centering
		\includegraphics[width=0.8\textwidth]{images/wings-list.png}
		\caption{<<Крылатое>> представление} 
		\label{fig:wings-list} 
	\end{figure}
\end{enumerate}

Для хранения полигональной сетки будет использован метод, основанный на списке граней, что обеспечивает ясное представление о гранях. Этот подход способствует эффективному преобразованию моделей, так как структура включает в себя список вершин.

\clearpage

\section{Анализ алгоритмов удаления невидимых линий и поверхностей}

Главной целью при создании реалистичного изображения является удаление объектов или их частей, которые не видны наблюдателю из-за перекрытия другими объектами. Для решения этой задачи выделяют две категории алгоритмов:

\begin{itemize}[label=--]
	\item \textit{Алгоритмы, работающие в объектном пространстве,} привязаны к мировой или физической системе координат. Их результаты зависят только от точности вычислений и требуют значительных вычислительных ресурсов, что зависит от необходимой точности и сложности входной сцены. К этой категории относятся алгоритмы Робертса, алгоритмы со списком приоритетов и другие.
	
	\item \textit{Алгоритмы, работающие в пространстве изображения,} ориентированы на систему координат экрана или картинной плоскости, на которую проецируются объекты. Объем вычислений в этой группе значительно меньше по сравнению с первой, и он зависит от разрешающей способности экрана и количества объектов в сцене. К основным алгоритмам этой группы относятся алгоритм Варнока, алгоритм Z-буфера и алгоритм трассировки лучей.
\end{itemize}

\subsection{Алгоритм Робертса}

Алгоритм Робертса — это первое известное решение задачи об удалении невидимых линий в трехмерной графике. Он представляет собой математически элегантный метод, работающий в объектном пространстве. Основная задача алгоритма заключается в удалении ребер и граней, которые экранируются самим объектом, а затем в сравнении оставшихся видимых ребер с другими объектами для определения их видимости.

Работа Алгоритма Робертса проходит в два этапа:
\begin{itemize}[label=--]
	\item определение нелицевых граней для каждого тела отдельно;
	\item определение и удаление невидимых ребер.
\end{itemize}

Для корректной работы данного алгоритма, необходимо выполнение следующих предварительных условий:
\begin{itemize}[label=--]
	\item тело ограничено плоскостями;
	\item нормали всех граней направлены внутрь тела;
	\item тело выпукло (невыпуклые тела должны быть разбиты на выпуклые части).
\end{itemize}

В этом алгоритме выпуклое многогранное тело с плоскими гранями должно представиться набором пересекающихся плоскостей. Уравнение произвольной плоскости в трехмерном пространстве имеет вид:
\begin{equation}
	ax + by + cz + d = 0
	\label{eq:plane-eq}
\end{equation}

В матричной форме уравнение \ref{eq:plane-eq} выглядит так:
\begin{equation}
	\begin{pmatrix}
		x & y & z & 1
	\end{pmatrix}
	\begin{pmatrix}
		a \\
		b \\
		c \\
		d \\
	\end{pmatrix}
	= 0
	\label{eq:matrix-plane-eq1}
\end{equation}

Тогда набор пересекающихся плоскостей состоит из матрицы коэффициентов уравнений плоскостей и называется \textit{матрицей тела}:
\begin{equation}
	V = 
	\begin{pmatrix}
		a_1 & a_2 & \cdots & a_n \\
		b_1 & b_2 & \cdots & b_n \\
		c_1 & c_2 & \cdots & c_n \\
		d_1 & d_2 & \cdots & d_n
	\end{pmatrix}
	\label{eq:model-matrix}
\end{equation}

Корректное формирование матрицы тела предполагает, что любая точка внутри него должна находиться по положительную сторону от каждой грани. Если это условие не соблюдено для определенной грани, следует умножить соответствующий столбец матрицы на -1. Для проверки правильности можно взять точку, находящуюся внутри тела, координаты которой вычисляются как среднее значение координат всех его вершин.

Далее удаляются грани, которые скрыты телом. Для этого используется вектор взгляда $E = (0 \ 0 \ -1 \ 0)$, и чтобы определить невидимые грани, вектор умножается на матрицу тела $V$. Отрицательные компоненты результата указывают на невидимые грани.

Для выявления невидимых точек на ребре необходимо провести луч от наблюдателя к точке наблюдения. Если луч сталкивается с каким-либо объектом, то точка считается невидимой. Если объект действительно препятствует прохождению луча, он должен пересекать этот объект, оставаясь по положительную сторону от каждой его грани.

Вычислительная сложность алгоритма возрастает теоретически как квадрат числа объектов, то есть его главный недостаток -- скорость работы. К тому же, этот алгоритм сложнореализуемый из-за его полностью математической структуры.

Основное преимущество данного алгоритма заключается в высокой точности вычислений, которая достигается благодаря работе в объектном пространстве, в отличие от большинства других алгоритмов.

\subsection{Алгоритм Варнока}

Алгоритм Варнока основывается на гипотезе о том, как человеческий глаз и мозг обрабатывают информацию в сцене. Эта гипотеза утверждает, что на обработку областей с низким информационным содержанием уходит значительно меньше времени и усилий, чем на области с высоким содержанием информации.

Конкретная реализация алгоритма зависит от метода разбиения окна и от критериев, используемых для определения простоты содержимого окна. В оригинальной версии алгоритма каждое окно делится на четыре равных подокна. Многоугольник в изображаемой сцене может быть классифицирован следующим образом (рис. \ref{fig:varnok-models}):
\begin{itemize}[label=--]
	\item \textit{внешний}, если он находится полностью вне окна;
	\item \textit{внутренний}, если он находится полностью внутри окна;
	\item \textit{пересекающий}, если он пересекает границу окна;
	\item \textit{охватывающий}, если окно находится полностью внутри него.
\end{itemize}

\begin{figure}[h] 
	\centering
	\includegraphics[width=0.8\textwidth]{images/varnok-models.png}
	\caption{Типы многоугольников в алгоритме Варнока: внешний (a), внутренний (b), пересекающий (c), охватывающий (d)} 
	\label{fig:varnok-models} 
\end{figure}

Алгоритм можно описать в общих чертах следующим образом:
\begin{enumerate}
	\item если все многоугольники сцены являются внешними по отношению к окну, то окно считается пустым, заполняется фоновым цветом и дальнейшему разбиению не подлежит.
	\item если только один многоугольник пересекает окно и является внутренним, окно заполняется фоновым цветом, а сам многоугольник — своим цветом.
	\item если только один многоугольник пересекает окно и является пересекающим, окно заполняется фоновым цветом, а часть многоугольника, которая принадлежит окну, заполняется цветом этого многоугольника.
	\item если только один многоугольник охватывает окно и нет других многоугольников, имеющих общие точки с окном, то окно заполняется цветом этого многоугольника.
	\item если существует хотя бы один охватывающий окно многоугольник, из всех таких выбирается тот, который ближе всего к точке наблюдения, и окно заполняется его цветом.
	\item в противном случае производится новое разбиение окна.
\end{enumerate}

\begin{figure}[h] 
	\centering
	\includegraphics[width=0.6\textwidth]{images/varnok.png}
	\caption{Пример разбиения алгоритмом Варнока} 
	\label{fig:varnok} 
\end{figure}

Шаги 1–4 рассматривают случай пересечения окна только с одним многоугольником, что помогает уменьшить количество подразбиений. Шаг 5 решает проблему удаления невидимых поверхностей, так как многоугольник, находящийся ближе к наблюдателю, экранирует остальные. Пример разбиения приведён на рисунке \ref{fig:varnok}.

Основной недостаток алгоритма заключается в его рекурсивной работе. На каждом этапе он проверяет, какие грани видны, и если определение видимости нетривиально, окно разделяется на четыре секции, и анализ проводится отдельно для каждой из них.

\subsection{Алгоритм трассировки лучей}

Главная концепция алгоритма трассировки лучей состоит в том, что наблюдатель замечает объекты благодаря свету, исходящему от источников, который взаимодействует с объектами и, следуя законам оптики, достигает его глаза. В методе прямой трассировки создаются траектории лучей от всех источников света ко всем точкам объектов, что приводит к большому количеству обрабатываемых лучей и значительным вычислительным затратам, поскольку лишь небольшая часть лучей достигает точки наблюдения. 

\begin{figure}[h] 
	\centering
	\includegraphics[width=0.6\textwidth]{images/direct-ray-tracing.png}
	\caption{Алгоритм трассировки лучей} 
	\label{fig:direct-ray-tracing} 
\end{figure}

Этот алгоритм подходит для создания статических сцен и моделирования различных оптических эффектов, таких как отражение и преломление.

\subsection{Алгоритм обратной трассировки лучей}

Идея алгоритма обратной трассировки лучей состоит в том, что наблюдатель видит объекты благодаря свету, исходящему от источников, который отражается от объектов и достигает его глаз. Однако отслеживание путей лучей от источника к наблюдателю неэффективно с вычислительной точки зрения, поэтому более целесообразно отслеживать их в обратном направлении — от наблюдателя к объектам. Лучи исходят из камеры, проходя через каждый пиксель сцены, после чего определяется их пересечение с объектами. Если пересечение найдено, рассчитывается интенсивность пикселя с учетом расположения источников света. Наблюдатель считается находящимся на положительной полуоси $z$ в бесконечности, поэтому все лучи параллельны этой оси. 

\begin{figure}[h] 
	\centering
	\includegraphics[width=0.6\textwidth]{images/reverse-ray-tracing.png}
	\caption{Алгоритм обратной трассировки лучей} 
	\label{fig:reverse-ray-tracing} 
\end{figure}

При этом, несмотря на большую эффективность алгоритма по сравнению с прямой трассировкой, он все же медленный из-за необходимости точно рассчитывать сложные аналитические выражения для нахождения пересечений с объектами.

\subsection{Алгоритм художника}

Алгоритм художника предполагает сортировку всех полигонов сцены по удаленности от наблюдателя. Объекты, находящиеся дальше от камеры, рендерятся первыми, а затем последовательно добавляются более близкие объекты. 

Например, в сцене с горами, лугом и деревьями, изображенными на рисунке \ref{fig:painter-example}, правильный порядок рендеринга будет: горы $\rightarrow$ луг $\rightarrow$ деревья.

\begin{figure}[h] 
	\centering
	\includegraphics[width=0.8\textwidth]{images/painter.png}
	\caption{Последовательная работа алгоритма художника} 
	\label{fig:painter-example} 
\end{figure}

Несмотря на свою простоту, алгоритм художника имеет несколько значительных недостатков:
\begin{itemize}[label=--]
	\item если полигоны пересекаются, определить правильный порядок их рисования становится невозможно. Например, если три полигона накладываются друг на друга (рис. \ref{fig:painter-problem}), то независимо от порядка сортировки, результат будет некорректным. Для решения этой проблемы может потребоваться разбивка конфликтующих полигонов на меньшие части, что усложняет реализацию;
	\item алгоритм также может прорисовывать области, которые впоследствии будут перекрыты другими объектами. Это приводит к ненужным затратам процессорного времени и ресурсов, так как рендерятся объекты, которые не будут видны в конечном результате.
\end{itemize}

\begin{figure}[h] 
	\centering
	\includegraphics[width=0.3\textwidth]{images/painter-problem.png}
	\caption{Взаимноперекрывающиеся полигоны} 
	\label{fig:painter-problem} 
\end{figure}

Из-за этих недостатков был разработан алгоритм $Z$-буфера, который представляет собой более эффективный способ обработки видимости.

\subsection{Алгоритм $Z$-буфера}

Алгоритм $z$-буфера представляет собой один из наиболее простых способов удаления невидимых объектов, работающий в пространстве изображения. Он основан на концепции буфера кадра, который сохраняет интенсивность каждого пикселя, и дополнительно использует  $z$-буфер для хранения координат глубины видимых пикселей. Во время работы алгоритм сравнивает глубину нового пикселя с уже сохраненной в  $z$-буфере. Если новый пиксель находится ближе к наблюдателю, он добавляется в буфер кадра, а значение глубины обновляется. Если же он дальше, то ничего не происходит. Таким образом, алгоритм фактически ищет максимальное значение функции $z(x, y)$.

Формально алгоритм можно описать следующим образом:
\begin{enumerate}
	\item инициализировать буфер кадра фоновым значением цвета или интенсивности.
	\item заполнить $z$-буфер минимальными значениями глубины.
	\item преобразовать многоугольники в растровую форму в произвольном порядке.
	\item для каждого пикселя $(x, y)$ в многоугольнике вычислить его глубину $z(x, y)$.
	\item если $z(x, y) > Z_{\text{\textit{буфер}}}(x, y)$ (ближе к наблюдателю), обновить буфер кадра и $z$-буфер, иначе никаких действий не предпринимать.
\end{enumerate}

\begin{figure}[h] 
	\centering
	\includegraphics[width=0.9\textwidth]{images/zbuffer.png}
	\caption{Пример заполнения $z$-буфера} 
	\label{fig:zbuffer} 
\end{figure}

Главное преимущество этого метода — его простота. Он эффективно решает задачу удаления невидимых объектов и позволяет легко визуализировать пересечения сложных форм. Алгоритм обладает линейной вычислительной сложностью, так как порядок добавления элементов не имеет значения, что исключает необходимость предварительной сортировки по глубине.

Основной недостаток алгоритма – большой объём требуемой памяти. Однако, поскольку размер создаваемого изображения относительно небольшой, затраты памяти на хранение информации о каждом пикселе в этом алгоритме незначительны для современных компьютеров.

\subsection{Выбор оптимального алгоритма}

Для удаления невидимых линий и поверхностей был выбран алгоритм $Z$-буфера. Данный алгоритм прост в своей реализации, производителен и позволяет добиться достаточной детализации синтезируемого изображения.

\section{Анализ модели освещения}

Модели освещения являются основным инструментом для создания реалистичных изображений. Они описывают, как свет взаимодействует с поверхностями объектов и как это взаимодействие влияет на восприятие цвета и яркости. Модели освещения можно разделить на две основные категории:
\begin{itemize}[label=--]
	\item \textit{Локальные} модели освещения рассматривают освещение на уровне отдельной поверхности, не учитывая влияние света от других объектов. Эти модели обычно используют упрощенные подходы для расчета освещения и являются более производительными, что делает их подходящими для реального времени;
	\item \textit{Глобальные} модели освещения учитывают взаимодействие света между различными объектами в сцене, что позволяет создавать более реалистичные изображения. Эти модели обычно требуют больше вычислительных ресурсов.
\end{itemize}

\subsection{Модель Ламберта}

Модель Ламберта, также известная как модель диффузного отражения, основана на предположении, что интенсивность света, отраженного от поверхности, пропорциональна косинусу угла между нормалью к поверхности и направлением на источник света. Это означает, что поверхность будет выглядеть ярче, когда она освещается под прямым углом и темнее, когда свет падает под острым углом. 
\begin{figure}[h] 
	\centering
	\includegraphics[width=0.55\textwidth]{images/lambert.png}
	\caption{Модель Ламберта} 
	\label{fig:lambert} 
\end{figure}

При этом положение наблюдателя не влияет на восприятие, поскольку свет, отраженный диффузно, распределяется равномерно во всех направлениях.

Формула для расчета диффузного освещения в модели Ламберта выглядит следующим образом:
\begin{equation}
	I = I_0 \cdot k_d \cdot cos(\vec{L}, \vec{N}) = I_0 \cdot k_d \cdot (\vec{L} \cdot \vec{N})
	\label{eq:lambert}
\end{equation}
где $I$ -- результирующая интенсивность света в точке, $I_0$ -- интенсивность источника света, $k_d$ -- коэффициент диффузного освещения, $\vec{L}$ -- вектор от точки до источника и $\vec{N}$ -- нормаль в точке.

\subsection{Модель Фонга}
Модель Фонга является классической моделью освещения, которая сочетает в себе диффузную составляющую и зеркальную составляющую. Это позволяет не только обеспечить равномерное освещение, но и создавать блики на материале. Положение блика на объекте, освещенном по модели Фонга, определяется законом равенства углов падения и отражения. Если наблюдатель находится близко к углу отражения, яркость данной точки увеличивается.
\begin{figure}[h] 
	\centering
	\includegraphics[width=0.9\textwidth]{images/phong-example.png}
	\caption{Компоненты модели Фонга: рассеяная (a), диффузная (b), зеркальная (c), суммарная (d)} 
	\label{fig:phong-example} 
\end{figure}

Падающий и отраженный лучи расположены в одной плоскости с нормалью к поверхности в точке падения, и эта нормаль делит угол между лучами пополам. Таким образом, отраженная составляющая освещенности в данной точке зависит от того, насколько близки направления на наблюдателя и отраженный луч.
\begin{figure}[h] 
	\centering
	\includegraphics[width=0.55\textwidth]{images/phong.png}
	\caption{Модель Фонга} 
	\label{fig:phong} 
\end{figure}

Формула для расчета освещения в модели Фонга выглядит следующим образом:
\begin{equation}
	I = I_a + I_d + I_s
\end{equation}
где $I_a$ -- рассеяная составляющая, $I_d$ -- диффузная составляющая и $I_s$ -- зеркальная составляющая.

\begin{equation}
	I_a = I_a \cdot k_a
\end{equation}
где $I_a$ -- интенсивность рассеянного освещения и $k_a$ -- коэффициент рассеянного освещения.

\begin{equation}
	I_d = I_0 \cdot k_d \cdot cos(\vec{L}, \vec{N}) = I_0 \cdot k_d \cdot (\vec{L} \cdot \vec{N})
\end{equation}
где $I_0$ -- интенсивность источника света, $k_d$ -- коэффициент диффузного освещения, $\vec{L}$ -- вектор от точки до источника и $\vec{N}$ -- нормаль в точке.

\begin{equation}
	I_s = I_0 \cdot k_s \cdot cos^{\alpha}(\vec{R}, \vec{V}) = I_0 \cdot k_s \cdot (\vec{R} \cdot \vec{V})^{\alpha}
	\label{eq:specular}
\end{equation}
где $k_s$ -- коэффициент зеркального освещения, $\vec{R}$ -- вектор отраженного луча и $\vec{V}$ -- вектор от точки до наблюдателя.

\begin{equation}
	\vec{R} = 2 \cdot (\vec{N} \cdot \vec{L}) \cdot \vec{N} - \vec{L}
\end{equation}
где $\vec{R}$ -- вектор отраженного луча, $\vec{N}$ -- нормаль в точке и $\vec{L}$ -- вектор от точки до источника.

\subsection{Модель Блинна-Фонга}
Модель Блинна-Фонга представляет собой упрощение модели Фонга, используемое для расчета зеркального отражения света на поверхностях с меньшими вычислительными затратами. Основная идея заключается в использовании вектора полупути $\vec{H}$, который определяется как:
\begin{equation}
	\vec{H} = \frac{\vec{L} + \vec{V}}{|\vec{L} + \vec{V}|}
\end{equation}
где  $\vec{L}$ -- вектор от точки до источника и $\vec{V}$ -- вектор от точки до наблюдателя. 

\begin{figure}[h] 
	\centering
	\includegraphics[width=0.55\textwidth]{images/blinn-phong.png}
	\caption{Модель Блинна-Фонга} 
	\label{fig:blinn-phong} 
\end{figure}

Вектор $\vec{H}$ называется вектором полупути, поскольку, если все три вектора $\vec{V}$, $\vec{L}$ и $\vec{N}$ лежат в одной плоскости, то угол между $\vec{H}$ и $\vec{N}$ составляет половину угла между $\vec{R}$ и $\vec{V}$. Величину $(\vec{R} \cdot \vec{V})^{\alpha}$ необходимую при расчёте зеркальной составляющей интенсивности $I_s$ в модели Фонга (\ref{eq:specular}) можно заменить на величину $(\vec{H} \cdot \vec{N})^{\beta}$.

Вектор $\vec{H}$ показывает ориентацию поверхности, на которой будет максимальное отражение света. В ряде случаев модель Блинна-Фонга требует значительно меньше вычислений, например в случае направленного бесконечно-удаленного источника.

\subsection{Выбор оптимальной модели освещения}

В качестве модели освещения была выбрана модель Фонга. Данная модель учитывает как диффузное, так и зеркальное отражение света, что делает синтезируемое изображение более реалистичным и способствует возникновению бликов света.

\section{Анализ алгоритмов закрашивания}

Алгоритмы закрашивания определяют, как поверхности объектов будут окрашены в зависимости от их геометрии, освещения и материалов.

\subsection{Простая закраска}

Данный алгоритм представляет простейший способ закраски. Для многогранных объектов высчитываются уровни интенсивности для каждой грани согласно закону Ламберта~(\ref{eq:lambert}) и закраска каждой грани соответствует её уровню интенсивности. Это делает процесс рендеринга простым и быстрым, поскольку не требует сложных расчетов для каждой точки на поверхности.

\begin{figure}[h] 
	\centering
	\includegraphics[width=0.35\textwidth]{images/simple-shading.png}
	\caption{Аппроксимированная сфера, закрашенная алгоритом простой закраски} 
	\label{fig:simple-shading} 
\end{figure}

Однако, простая закраска может привести к тому, что границы между соседними гранями будут слишком резкими и заметными. Это можно исправить увеличением количества граней объекта. 

\subsection{Закраска Гуро}

В отличие от простой закраски, где освещение рассчитывается для всей грани, в закраске Гуро нормали определяются в вершинах модели. Это позволяет учитывать освещение на более детальном уровне и обеспечивает более плавные переходы между цветами.

Нормали к вершинам модели вычисляются путем усреднения нормалей всех граней, которые соединяются в данной вершине. Это позволяет учитывать влияние нескольких граней на освещение в этой точке. После того как нормали вершин определены, можно вычислить освещенность каждой вершины. Закраска осуществляется вдоль рёбер многоугольников с использованием билинейной интерполяции значений интенсивности цвета в вершинах. Это позволяет создать плавный переход между цветами, что визуально сглаживает поверхность.

\begin{figure}[h] 
	\centering
	\includegraphics[width=0.35\textwidth]{images/gurou-shading.png}
	\caption{Аппроксимированная сфера, закрашенная алгоритом Гуро} 
	\label{fig:gurou-shading} 
\end{figure}

Одним из основных недостатков затенения по Гуро является то, что при низком уровне детализации блики на поверхности могут быть смазаны или потеряны.

\subsection{Закраска Фонга}

В отличие от закраски Гуро, где цвета интерполируются между вершинами, в закраске Фонга интерполируются нормали. Цвет, в свою очередь, рассчитывается для каждого пикселя в отдельности. При использовании закраски Фонга изображение получается гораздо более качественным, чем при использовании предыдущих техник, и исчезает проблема с бликами.

\begin{figure}[h] 
	\centering
	\includegraphics[width=0.35\textwidth]{images/phong-shading.png}
	\caption{Аппроксимированная сфера, закрашенная алгоритом Фонга} 
	\label{fig:phong-shading} 
\end{figure}

Одним из основных недостатков является необходимость выполнять большое количество вычислений.

\subsection{Выбор оптимального алгоритма закраски}

Для закраски был выбран алгоритм Фонга. Данный алгоритм несмотря на его вычислительные затраты позволит обеспечить реалистичное освещение и четкие блики.

\section{Анализ алгоритма построения теней}

Для построения теней был выбран модифицированный алгоритм $Z$-буфера с добавлением теней, так как он работает с направленным источником света. Этот модифицированный алгоритм состоит из двух шагов:
\begin{itemize}[label=--]
	\item cцена строится из точки наблюдения, совпадающей с источником света. Значения $z$ для этого вида сохраняются в отдельном теневом $z$-буфере, при этом значения интенсивности не учитываются.
	\item затем сцена строится из точки, где находится наблюдатель. При обработке каждой поверхности или многоугольника глубина в каждом пикселе сравнивается с глубиной в $z$-буфере наблюдателя. Если поверхность видима, координаты $x$, $y$, $z$ из вида наблюдателя линейно преобразуются в координаты $x'$, $y'$, $z'$ для вида из источника. Чтобы проверить, видимо ли значение $z'$ из положения источника, оно сравнивается со значением теневого $z$-буфера при $x'$, $y'$. Если значение $z'$ видимо, оно отображается в буфере кадра в точке $x$, $y$ без изменений. В противном случае точка находится в тени и отображается в соответствии с правилом расчета интенсивности с учетом затенения, а значение в $z$-буфере наблюдателя обновляется на $z'$.
\end{itemize}

Этот метод создания теней требует значительных вычислительных ресурсов, но эти расчеты выполняются лишь при изменении сцены. Таким образом, если камера остается на одном месте, повторные вычисления значений в теневом $Z$-буфере не нужны.

\section{Вывод}

В аналитическом разделе работы был проведен детальный анализ объектов сцены, способов их представления, алгоритмов удаления невидимых линий и поверхностей, моделей освещения и закрашивания, а также алгоритма построения теней. Был сделан в пользу поверхностной модели, заданной полигональной сеткой, алгоритма $Z$-буфера, модели освещения Фонга, закраски Фонга и модифицированного алгоритма $Z$-буфера с добавлением теней.

\clearpage
